# 🍽️ 맛집 추천 앱 프로젝트 완벽 가이드

> **수업 시간**: 2-3시간  
> **대상**: 프로그래밍 입문자부터 중급자까지  
> **목표**: 실무에서 사용하는 모던 앱 개발 기술스택 이해하기

---

## 📋 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [전체 시스템 아키텍처](#2-전체-시스템-아키텍처)
3. [기술 스택 상세 분석](#3-기술-스택-상세-분석)
4. [백엔드 서버 분석](#4-백엔드-서버-분석)
5. [데이터베이스 설계](#5-데이터베이스-설계)
6. [Android 앱 구조](#6-android-앱-구조)
7. [주요 기능 구현 방법](#7-주요-기능-구현-방법)
8. [실습 과제](#8-실습-과제)

---

## 1. 프로젝트 개요

### 🎯 프로젝트 목표
"**사용자 위치 기반 맛집 추천 Android 앱**"을 만들어보면서 현대적인 앱 개발의 전체 과정을 학습합니다.

### ✨ 주요 기능
- 📍 사용자 위치 기반 맛집 검색
- ⭐ 맛집 평점 및 리뷰 시스템
- 🔖 북마크 및 즐겨찾기 기능
- 🗺️ 지도에서 맛집 위치 표시
- 👤 사용자 인증 (로그인/회원가입)
- 🔍 카테고리별 맛집 필터링

### 🎓 학습 목표
1. **풀스택 개발 이해**: 프론트엔드(Android) + 백엔드(Node.js) + 데이터베이스(MongoDB)
2. **실무 개발 패턴**: MVVM, Repository Pattern, REST API
3. **최신 기술스택**: Kotlin, Room, Retrofit, Express.js, Mongoose
4. **개발 도구 활용**: Android Studio, Postman, MongoDB Compass

---

## 2. 전체 시스템 아키텍처

```
📱 Android App (클라이언트)
    ↕️ HTTP/HTTPS 통신
🖥️ Node.js Server (백엔드)
    ↕️ 데이터 저장/조회
🗄️ MongoDB (데이터베이스)
```

### 🔄 데이터 흐름
1. **사용자 요청**: Android 앱에서 버튼 클릭 또는 검색
2. **API 호출**: HTTP 요청으로 서버에 데이터 요청
3. **서버 처리**: Node.js에서 비즈니스 로직 처리
4. **데이터베이스 조회**: MongoDB에서 데이터 검색/저장
5. **응답 반환**: JSON 형태로 앱에 결과 전달
6. **화면 업데이트**: 받은 데이터로 UI 갱신

---

## 3. 기술 스택 상세 분석

### 📱 Android 앱 (프론트엔드)

| 기술 | 역할 | 왜 사용했나? |
|------|------|-------------|
| **Kotlin** | 프로그래밍 언어 | Java보다 간결하고 안전한 언어 |
| **Android Jetpack** | UI 및 라이프사이클 관리 | 구글이 권장하는 모던 개발 방식 |
| **Room Database** | 로컬 데이터베이스 | 오프라인에서도 데이터 접근 가능 |
| **Retrofit** | 네트워크 통신 | REST API 호출을 쉽게 만들어줌 |
| **MVVM Pattern** | 아키텍처 패턴 | UI와 비즈니스 로직을 분리 |
| **Hilt** | 의존성 주입 | 코드 재사용성과 테스트 용이성 |

#### 🔍 **초보자를 위한 설명**
- **Kotlin**: 안드로이드 개발용 언어. 자바보다 쓰기 쉽고 오류가 적음
- **Room**: 핸드폰 안에 작은 데이터베이스. 인터넷 없어도 데이터 저장 가능
- **Retrofit**: 인터넷으로 서버와 대화하는 도구
- **MVVM**: 화면(View) + 데이터처리(ViewModel) + 실제데이터(Model)로 역할 분담

### 🖥️ 백엔드 서버

| 기술 | 역할 | 왜 사용했나? |
|------|------|-------------|
| **Node.js** | 서버 런타임 | JavaScript로 서버 개발 가능 |
| **Express.js** | 웹 프레임워크 | 빠르고 간단한 API 서버 구축 |
| **MongoDB** | NoSQL 데이터베이스 | JSON 형태 데이터 저장에 최적화 |
| **Mongoose** | ODM 라이브러리 | MongoDB 사용을 쉽게 만들어줌 |
| **JWT** | 인증 토큰 | 사용자 로그인 상태 관리 |
| **bcrypt** | 암호화 | 비밀번호 안전하게 저장 |

#### 🔍 **초보자를 위한 설명**
- **Node.js**: 자바스크립트로 서버 프로그램을 만들 수 있게 해주는 도구
- **Express.js**: 웹사이트나 API를 쉽게 만들 수 있는 라이브러리
- **MongoDB**: 데이터를 JSON 형태로 저장하는 현대적인 데이터베이스
- **JWT**: 로그인한 사용자가 누구인지 확인하는 디지털 신분증

---

## 4. 백엔드 서버 분석

### 📁 프로젝트 구조
```
restaurant-server/
├── 📄 server.js           # 서버 메인 파일
├── 📁 models/            # 데이터 모델 정의
│   ├── User.js           # 사용자 모델
│   └── Restaurant.js     # 맛집 모델
├── 📁 routes/            # API 라우트
│   ├── auth.js           # 인증 관련 API
│   ├── users.js          # 사용자 관련 API
│   └── restaurants.js    # 맛집 관련 API
├── 📁 middleware/        # 미들웨어
│   └── auth.js           # 인증 검증
├── 📁 scripts/           # 유틸리티 스크립트
│   └── seedDatabase.js   # 초기 데이터 생성
└── 📄 package.json       # 프로젝트 설정 및 의존성
```

### 🔧 주요 API 엔드포인트

#### 👤 인증 관련 (auth.js)
```javascript
POST /api/auth/register    # 회원가입
POST /api/auth/login       # 로그인
POST /api/auth/logout      # 로그아웃
GET  /api/auth/me          # 내 정보 조회
```

#### 🍽️ 맛집 관련 (restaurants.js)
```javascript
GET    /api/restaurants           # 맛집 목록 조회
GET    /api/restaurants/:id       # 특정 맛집 상세 조회
POST   /api/restaurants           # 새 맛집 등록
PUT    /api/restaurants/:id       # 맛집 정보 수정
DELETE /api/restaurants/:id       # 맛집 삭제
GET    /api/restaurants/nearby    # 주변 맛집 검색
```

### 📋 서버 주요 기능

#### 1️⃣ **보안 기능**
```javascript
// 1. CORS 설정 - 특정 도메인에서만 접근 허용
app.use(cors({
    origin: ['http://localhost:3000', 'http://10.0.2.2:5159'],
    credentials: true
}));

// 2. Rate Limiting - API 남용 방지
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15분
    max: 100 // 최대 100회 요청
});

// 3. 헬멧 보안 헤더 설정
app.use(helmet());
```

#### 2️⃣ **에러 처리**
```javascript
// 전역 에러 핸들러
app.use((error, req, res, next) => {
    if (error.name === 'ValidationError') {
        // 입력 데이터 검증 오류
        return res.status(400).json({
            success: false,
            error: '입력 데이터가 올바르지 않습니다.'
        });
    }
    
    // 기본 서버 오류
    res.status(500).json({
        success: false,
        error: '서버 내부 오류가 발생했습니다.'
    });
});
```

---

## 5. 데이터베이스 설계

### 🗄️ MongoDB 컬렉션 구조

#### 👤 User (사용자) 컬렉션
```javascript
{
  _id: ObjectId,              // 고유 ID
  username: String,           // 사용자명
  email: String,              // 이메일 (로그인용)
  password: String,           // 암호화된 비밀번호
  bookmarks: [ObjectId],      // 북마크한 맛집 ID들
  favorites: [ObjectId],      // 즐겨찾기한 맛집 ID들
  location: {                 // 사용자 위치
    type: "Point",
    coordinates: [lng, lat]   // [경도, 위도]
  },
  preferences: {              // 사용자 선호 설정
    favoriteCategories: [String],
    priceRange: String,
    dietaryRestrictions: [String]
  },
  createdAt: Date,           // 가입일
  updatedAt: Date            // 마지막 수정일
}
```

#### 🍽️ Restaurant (맛집) 컬렉션
```javascript
{
  _id: ObjectId,              // 고유 ID
  name: String,               // 맛집 이름
  category: String,           // 카테고리 (한식, 중식, 일식 등)
  address: String,            // 주소
  location: {                 // 위치 정보
    type: "Point",
    coordinates: [lng, lat]   // [경도, 위도]
  },
  phone: String,              // 전화번호
  rating: Number,             // 평균 평점 (0-5)
  reviewCount: Number,        // 리뷰 개수
  priceRange: String,         // 가격대 (저렴, 보통, 비싸, 고급)
  openingHours: String,       // 영업시간
  imageUrl: String,           // 대표 이미지 URL
  description: String,        // 설명
  menuItems: [{               // 메뉴 항목들
    name: String,             // 메뉴명
    price: Number,            // 가격
    description: String,      // 메뉴 설명
    isPopular: Boolean        // 인기 메뉴 여부
  }],
  businessHours: {            // 상세 영업시간
    monday: { open: String, close: String },
    tuesday: { open: String, close: String },
    // ... 나머지 요일들
  },
  features: [String],         // 특징 (주차가능, 24시간, 배달가능 등)
  tags: [String],             // 태그 (검색용)
  isActive: Boolean,          // 활성 상태
  createdAt: Date,           // 등록일
  updatedAt: Date            // 마지막 수정일
}
```

### 🔍 데이터베이스 인덱스 설정

#### 📍 **지리적 검색을 위한 2dsphere 인덱스**
```javascript
// 위치 기반 검색 최적화
restaurantSchema.index({ location: '2dsphere' });
userSchema.index({ location: '2dsphere' });
```

#### 🔤 **텍스트 검색을 위한 인덱스**
```javascript
// 맛집 이름, 설명, 태그로 검색 가능
restaurantSchema.index({ 
  name: 'text', 
  description: 'text', 
  tags: 'text' 
});
```

#### ⚡ **성능 최적화 인덱스**
```javascript
// 자주 사용되는 쿼리 조합
restaurantSchema.index({ category: 1, rating: -1 });
restaurantSchema.index({ rating: -1, reviewCount: -1 });
```

---

## 6. Android 앱 구조

### 📁 프로젝트 구조
```
app/src/main/java/com/restaurantapp/
├── 📄 MainActivity.kt                    # 메인 화면
├── 📁 data/                             # 데이터 레이어
│   ├── 📁 local/                        # 로컬 데이터
│   │   ├── AppDatabase.kt               # Room 데이터베이스
│   │   └── RestaurantDao.kt             # 데이터 접근 객체
│   ├── 📁 network/                      # 네트워크 통신
│   │   ├── ApiService.kt                # REST API 인터페이스
│   │   ├── AuthInterceptor.kt           # 인증 헤더 추가
│   │   └── NetworkModule.kt             # 네트워크 설정
│   ├── 📁 model/                        # 데이터 모델
│   │   ├── Restaurant.kt                # 맛집 데이터 클래스
│   │   └── User.kt                      # 사용자 데이터 클래스
│   └── 📁 repository/                   # 리포지토리 패턴
│       ├── AuthRepository.kt            # 인증 관련 데이터 관리
│       └── RestaurantRepository.kt      # 맛집 관련 데이터 관리
└── 📁 ui/                               # UI 레이어
    ├── 📁 adapter/                      # RecyclerView 어댑터
    ├── 📁 auth/                         # 로그인/회원가입 화면
    ├── 📁 detail/                       # 맛집 상세 화면
    ├── 📁 favorites/                    # 즐겨찾기 화면
    ├── 📁 map/                          # 지도 화면
    └── 📁 viewmodel/                    # ViewModel들
        ├── AuthViewModel.kt             # 인증 관련 로직
        └── RestaurantViewModel.kt       # 맛집 관련 로직
```

### 🏗️ MVVM 아키텍처 패턴

#### 🎯 **각 레이어의 역할**

1. **Model (데이터 모델)**
   - 데이터의 구조를 정의
   - 서버나 로컬 DB에서 가져온 데이터를 앱에서 사용할 형태로 변환

2. **View (화면/UI)**
   - 사용자에게 보이는 화면
   - 사용자의 입력을 받고 결과를 표시

3. **ViewModel (비즈니스 로직)**
   - View와 Model 사이의 중간 다리 역할
   - UI 로직과 데이터 처리 로직을 분리

#### 🔄 **데이터 흐름 예시: 맛집 목록 조회**

```kotlin
// 1. View에서 사용자가 "새로고침" 버튼 클릭
refreshButton.setOnClickListener {
    viewModel.loadRestaurants()
}

// 2. ViewModel에서 Repository에 데이터 요청
class RestaurantViewModel : ViewModel() {
    fun loadRestaurants() {
        viewModelScope.launch {
            repository.getRestaurants()
        }
    }
}

// 3. Repository에서 네트워크와 로컬 DB 관리
class RestaurantRepository {
    suspend fun getRestaurants(): List<Restaurant> {
        return try {
            // 서버에서 최신 데이터 가져오기
            val serverData = apiService.getRestaurants()
            // 로컬 DB에 저장
            dao.insertAll(serverData)
            serverData
        } catch (e: Exception) {
            // 네트워크 오류 시 로컬 데이터 반환
            dao.getAllRestaurants()
        }
    }
}

// 4. View에서 결과 관찰하고 UI 업데이트
viewModel.restaurants.observe(this) { restaurants ->
    adapter.submitList(restaurants)
}
```

### 📚 주요 Android 라이브러리 설명

#### 🏠 **Room Database**
```kotlin
// 로컬 데이터베이스 엔티티 정의
@Entity(tableName = "restaurants")
data class Restaurant(
    @PrimaryKey val id: String,
    val name: String,
    val category: String,
    val rating: Double,
    val isBookmarked: Boolean = false
)

// 데이터 접근 인터페이스 정의
@Dao
interface RestaurantDao {
    @Query("SELECT * FROM restaurants")
    suspend fun getAllRestaurants(): List<Restaurant>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(restaurants: List<Restaurant>)
}
```

#### 🌐 **Retrofit (네트워크 통신)**
```kotlin
// API 인터페이스 정의
interface ApiService {
    @GET("restaurants")
    suspend fun getRestaurants(): List<RestaurantDto>
    
    @GET("restaurants/{id}")
    suspend fun getRestaurant(@Path("id") id: String): RestaurantDto
    
    @POST("auth/login")
    suspend fun login(@Body request: LoginRequest): LoginResponse
}
```

#### 💉 **Hilt (의존성 주입)**
```kotlin
// 의존성 주입 설정
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl("http://10.0.2.2:5159/api/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

---

## 7. 주요 기능 구현 방법

### 📍 1. 위치 기반 맛집 검색

#### 🖥️ **서버 구현**
```javascript
// MongoDB의 지리적 쿼리 사용
router.get('/nearby', async (req, res) => {
    const { lat, lng, maxDistance = 5000 } = req.query;
    
    const restaurants = await Restaurant.find({
        location: {
            $near: {
                $geometry: {
                    type: 'Point',
                    coordinates: [lng, lat]
                },
                $maxDistance: maxDistance // 미터 단위
            }
        },
        isActive: true
    });
    
    res.json({ success: true, data: restaurants });
});
```

#### 📱 **Android 구현**
```kotlin
// 위치 권한 요청 후 현재 위치 얻기
private fun getCurrentLocationAndSearchNearby() {
    if (checkLocationPermission()) {
        fusedLocationClient.lastLocation
            .addOnSuccessListener { location ->
                if (location != null) {
                    viewModel.searchNearbyRestaurants(
                        location.latitude,
                        location.longitude
                    )
                }
            }
    }
}
```

### 🔐 2. 사용자 인증 시스템

#### 🖥️ **JWT 토큰 기반 인증**
```javascript
// 로그인 시 JWT 토큰 생성
const token = jwt.sign(
    { userId: user._id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
);

// 미들웨어에서 토큰 검증
const auth = (req, res, next) => {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
        return res.status(401).json({ error: '토큰이 필요합니다' });
    }
    
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).json({ error: '유효하지 않은 토큰입니다' });
    }
};
```

#### 📱 **Android에서 토큰 관리**
```kotlin
// SharedPreferences에 토큰 저장
class AuthRepository @Inject constructor(
    private val sharedPreferences: SharedPreferences,
    private val apiService: ApiService
) {
    fun saveAuthToken(token: String) {
        sharedPreferences.edit()
            .putString("auth_token", token)
            .apply()
    }
    
    fun getAuthToken(): String? {
        return sharedPreferences.getString("auth_token", null)
    }
}

// HTTP 요청에 자동으로 토큰 추가
class AuthInterceptor @Inject constructor(
    private val authRepository: AuthRepository
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalRequest = chain.request()
        val token = authRepository.getAuthToken()
        
        val newRequest = if (token != null) {
            originalRequest.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            originalRequest
        }
        
        return chain.proceed(newRequest)
    }
}
```

### 🔖 3. 북마크 기능

#### 🖥️ **서버 구현**
```javascript
// 사용자 모델에 북마크 토글 메서드
userSchema.methods.toggleBookmark = function(restaurantId) {
    const bookmarkIndex = this.bookmarks.indexOf(restaurantId);
    if (bookmarkIndex > -1) {
        this.bookmarks.splice(bookmarkIndex, 1);
        return false; // 북마크 제거됨
    } else {
        this.bookmarks.push(restaurantId);
        return true; // 북마크 추가됨
    }
};

// API 엔드포인트
router.post('/bookmark/:restaurantId', auth, async (req, res) => {
    const user = await User.findById(req.user.userId);
    const isBookmarked = user.toggleBookmark(req.params.restaurantId);
    await user.save();
    
    res.json({ 
        success: true, 
        isBookmarked,
        message: isBookmarked ? '북마크에 추가되었습니다' : '북마크가 제거되었습니다'
    });
});
```

#### 📱 **Android 구현**
```kotlin
// ViewModel에서 북마크 토글
class RestaurantViewModel : ViewModel() {
    fun toggleBookmark(restaurantId: String) {
        viewModelScope.launch {
            try {
                val result = repository.toggleBookmark(restaurantId)
                if (result.isBookmarked) {
                    _message.value = "북마크에 추가되었습니다"
                } else {
                    _message.value = "북마크가 제거되었습니다"
                }
                loadRestaurants() // 목록 새로고침
            } catch (e: Exception) {
                _error.value = "북마크 처리 중 오류가 발생했습니다"
            }
        }
    }
}

// RecyclerView 어댑터에서 북마크 버튼 클릭 처리
binding.buttonBookmark.setOnClickListener {
    onBookmarkClick(restaurant)
}
```

---

## 8. 실습 과제

### 🎯 **난이도별 과제**

#### 🟢 **초급 과제 (30분)**
1. **새로운 맛집 카테고리 추가**
   - 서버: Restaurant 모델에 "분식" 카테고리 추가
   - 앱: 카테고리 필터에 "분식" 옵션 추가
   - 색상: 분식 카테고리용 새로운 색상 정의

2. **기본 UI 수정**
   - 앱 이름 변경
   - 로고 색상 변경
   - 버튼 스타일 커스터마이징

#### 🟡 **중급 과제 (60분)**
1. **맛집 상세 정보 추가**
   - 서버: Restaurant 모델에 `websiteUrl` 필드 추가
   - API: 웹사이트 URL 유효성 검증 추가
   - 앱: 상세 화면에 웹사이트 링크 버튼 추가

2. **검색 기능 개선**
   - 서버: 맛집명 자동완성 API 구현
   - 앱: 검색창에 실시간 자동완성 기능 추가

#### 🔴 **고급 과제 (90분)**
1. **리뷰 시스템 구현**
   - 서버: Review 모델 새로 생성
   - API: 리뷰 CRUD 기능 구현
   - 앱: 리뷰 작성/조회 화면 추가

2. **푸시 알림 시스템**
   - 서버: 새로운 맛집 등록 시 알림 발송
   - 앱: Firebase Cloud Messaging 연동

### 📝 **실습 체크리스트**

#### ✅ **개발 환경 설정**
- [ ] Android Studio 설치 및 프로젝트 임포트
- [ ] Node.js 및 npm 설치
- [ ] MongoDB 설치 및 실행
- [ ] Postman 설치 (API 테스트용)

#### ✅ **서버 실행**
- [ ] `npm install` 명령어로 의존성 설치
- [ ] MongoDB 서비스 시작
- [ ] `npm start`로 서버 실행
- [ ] http://localhost:5159 접속 확인

#### ✅ **앱 실행**
- [ ] Android Studio에서 프로젝트 열기
- [ ] Gradle 동기화 완료
- [ ] 에뮬레이터 또는 실제 기기에서 앱 실행

#### ✅ **기능 테스트**
- [ ] 회원가입/로그인 기능 테스트
- [ ] 맛집 목록 조회 테스트
- [ ] 북마크 기능 테스트
- [ ] 위치 기반 검색 테스트

---

## 💡 추가 학습 리소스

### 📚 **공식 문서**
- [Android 개발자 가이드](https://developer.android.com/guide)
- [Kotlin 언어 가이드](https://kotlinlang.org/docs/)
- [Node.js 공식 문서](https://nodejs.org/docs/)
- [MongoDB 매뉴얼](https://docs.mongodb.com/)
- [Express.js 가이드](https://expressjs.com/guide/)

### 🛠️ **개발 도구**
- [Android Studio](https://developer.android.com/studio) - Android 개발 IDE
- [Postman](https://www.postman.com/) - API 테스트 도구
- [MongoDB Compass](https://www.mongodb.com/products/compass) - MongoDB GUI 도구
- [VS Code](https://code.visualstudio.com/) - 서버 개발용 에디터

### 🎓 **심화 학습 주제**
1. **Android 고급**
   - Compose UI (최신 Android UI 툴킷)
   - Coroutines (비동기 프로그래밍)
   - WorkManager (백그라운드 작업)

2. **백엔드 고급**
   - Docker 컨테이너화
   - Redis 캐싱
   - AWS 배포

3. **데이터베이스 고급**
   - MongoDB 집계 파이프라인
   - 인덱스 최적화
   - 데이터베이스 설계 패턴

---

## 🎉 마무리

이 프로젝트를 통해 다음을 학습하게 됩니다:

1. **실무 개발 경험**: 실제 서비스와 유사한 구조의 앱 개발
2. **풀스택 이해**: 프론트엔드부터 백엔드, 데이터베이스까지 전체 시스템 이해
3. **모던 기술스택**: 현업에서 사용하는 최신 기술들 체험
4. **문제 해결 능력**: 실제 발생할 수 있는 이슈들을 직접 해결

### 🚀 **다음 단계**
1. **기능 확장**: 리뷰 시스템, 친구 기능, 소셜 로그인 등 추가
2. **성능 최적화**: 캐싱, 이미지 최적화, 로딩 속도 개선
3. **배포**: 실제 스토어에 앱 출시 및 서버 클라우드 배포
4. **유지보수**: 사용자 피드백 반영 및 지속적인 개선

**행운을 빕니다! 🍀**